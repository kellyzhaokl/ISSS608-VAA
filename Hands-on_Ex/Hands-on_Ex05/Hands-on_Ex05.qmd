---
title: "Hands-on Exercise 5"
date: "Feburary 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
editor: visual
---

# **`Creating Ternary Plot with R`**

## **1 Getting Started**

### **1.1 Installing and loading the packages**

```{r}
pacman::p_load(plotly, ggtern, tidyverse)
```

### **1.2 Data import**

```{r}
#Reading the data into R environment
pop_data <- read_csv("data/respopagsex2000to2018_tidy.csv") 
```

### **1.3 Data preparation**

Use the ***mutate()*** function of **dplyr** package to derive three new measures, namely: young, active, and old.

```{r}
#Deriving the young, economy active and old measures
agpop_mutated <- pop_data %>%
  mutate(`Year` = as.character(Year))%>%
  spread(AG, Population) %>%
  mutate(YOUNG = rowSums(.[4:8]))%>%
  mutate(ACTIVE = rowSums(.[9:16]))  %>%
  mutate(OLD = rowSums(.[17:21])) %>%
  mutate(TOTAL = rowSums(.[22:24])) %>%
  filter(Year == 2018)%>%
  filter(TOTAL > 0)
```

## **2 Plotting Ternary Diagram with R**

### **2.1 Plotting a static ternary diagram**

Use ***ggtern()*** function of **ggtern** package to create a simple ternary plot.

```{r}
#Building the static ternary plot
ggtern(data=agpop_mutated,aes(x=YOUNG,y=ACTIVE, z=OLD)) +
  geom_point()
```

```{r}
#Building the static ternary plot
ggtern(data=agpop_mutated, aes(x=YOUNG,y=ACTIVE, z=OLD)) +
  geom_point() +
  labs(title="Population structure, 2015") +
  theme_rgbw()
```

### **2.2 Plotting an interative ternary diagram**

The code below create an interactive ternary plot using ***plot_ly()*** function of **Plotly R**.

```{r}
# reusable function for creating annotation object
label <- function(txt) {
  list(
    text = txt, 
    x = 0.1, y = 1,
    ax = 0, ay = 0,
    xref = "paper", yref = "paper", 
    align = "center",
    font = list(family = "serif", size = 15, color = "white"),
    bgcolor = "#b3b3b3", bordercolor = "black", borderwidth = 2
  )
}

# reusable function for axis formatting
axis <- function(txt) {
  list(
    title = txt, tickformat = ".0%", tickfont = list(size = 10)
  )
}

ternaryAxes <- list(
  aaxis = axis("Young"), 
  baxis = axis("Active"), 
  caxis = axis("Old")
)

# Initiating a plotly visualization 
plot_ly(
  agpop_mutated, 
  a = ~YOUNG, 
  b = ~ACTIVE, 
  c = ~OLD, 
  color = I("black"), 
  type = "scatterternary"
) %>%
  layout(
    annotations = label("Ternary Markers"), 
    ternary = ternaryAxes
  )
```

# **`Heatmap for Visualising and Analysing Multivariate Data`**

## **1 Getting Started**

### **1.1 Installing and loading the packages**

```{r}
pacman::p_load(seriation, dendextend, heatmaply, tidyverse)
```

### **1.2 Data import**

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

### **1.3 Data preparation**

Next, we need to change the rows by country name instead of row number by using the code chunk below

```{r}
row.names(wh) <- wh$Country
```

### **1.4 Transforming the data frame into a matrix**

```{r}
wh1 <- dplyr::select(wh, c(3, 7:12))
wh_matrix <- data.matrix(wh)
```

## **2 Static Heatmap**

There are many R packages and functions can be used to drawing static heatmaps, they are:

-   [heatmap()](https://www.rdocumentation.org/packages/stats/versions/3.6.0/topics/heatmap)of R stats package. It draws a simple heatmap.

-   [heatmap.2()](https://www.rdocumentation.org/packages/gplots/versions/3.0.1.1/topics/heatmap.2) of **gplots** R package. It draws an enhanced heatmap compared to the R base function.

-   [pheatmap()](https://www.rdocumentation.org/packages/pheatmap/versions/1.0.12/topics/pheatmap) of [**pheatmap**](https://www.rdocumentation.org/packages/pheatmap/versions/1.0.12) R package. **pheatmap** package also known as Pretty Heatmap. The package provides functions to draws pretty heatmaps and provides more control to change the appearance of heatmaps.

-   [**ComplexHeatmap**](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html) package of R/Bioconductor package. The package draws, annotates and arranges complex heatmaps (very useful for genomic data analysis). The full reference guide of the package is available [here](https://jokergoo.github.io/ComplexHeatmap-reference/book/).

-   [**superheat**](https://cran.r-project.org/web/packages/superheat/) package: A Graphical Tool for Exploring Complex Datasets Using Heatmaps. A system for generating extendable and customizable heatmaps for exploring complex datasets, including big data and data with multiple data types. The full reference guide of the package is available [here](https://rlbarter.github.io/superheat/).

### **2.1 heatmap() of R Stats**

In this sub-section, we will plot a heatmap by using *heatmap()* of Base Stats. The code chunk is given below.

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      Rowv=NA, Colv=NA)
```

To plot a cluster heatmap, we just have to use the default as shown in the code chunk below.

```{r}
wh_heatmap <- heatmap(wh_matrix)
```

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      scale="column",
                      cexRow = 0.6, 
                      cexCol = 0.8,
                      margins = c(10, 4))
```

## **3 Creating Interactive Heatmap**

[**heatmaply**](http://talgalili.github.io/heatmaply/) is an R package for building interactive cluster heatmap that can be shared online as a stand-alone HTML file.

### **3.1 Working with heatmaply**

```{r}
heatmaply(mtcars)
```

The code chunk below shows the basic syntax needed to create n interactive heatmap by using **heatmaply** package.

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)])
```

### **3.2 Data trasformation**

Three main data transformation methods are supported by *heatmaply()*, namely: scale, normalise and percentilse.

#### 3.2.1 Scaling method

-   When all variables are came from or assumed to come from some normal distribution, then scaling (i.e.: subtract the mean and divide by the standard deviation) would bring them all close to the standard normal distribution.

-   In such a case, each value would reflect the distance from the mean in units of standard deviation.

-   The *scale* argument in *heatmaply()* supports column and row scaling.

The code chunk below is used to scale variable values columewise.

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)],
          scale = "column")
```

#### 3.2.2 Normalising method

-   When variables in the data comes from possibly different (and non-normal) distributions, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations.

-   This preserves the shape of each variable’s distribution while making them easily comparable on the same “scale”.

Different from Scaling, the normalise method is performed on the input data set i.e. wh_matrix as shown in the code chunk below.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))
```

#### 3.2.3 Percentising method

Similar to Normalize method, the Percentize method is also performed on the input data set i.e. wh_matrix as shown in the code chunk below.

```{r}
heatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))
```

### **3.3 Clustering algorithm**

### **3.3.1 Manual approach**

In the code chunk below, the heatmap is plotted by using hierachical clustering algorithm with “Euclidean distance” and “ward.D” method.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "ward.D")
```

### **3.3.2 Statistical approach**

In order to determine the best clustering method and number of cluster the *dend_expend()* and *find_k()* functions of **dendextend** package will be used.

First, the *dend_expend()* will be used to determine the recommended clustering method to be used.

```{r}
wh_d <- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = "euclidean")
dend_expend(wh_d)[[3]]
```

Next, *find_k()* is used to determine the optimal number of cluster.

```{r}
wh_clust <- hclust(wh_d, method = "average")
num_k <- find_k(wh_clust)
plot(num_k)
```

Figure above shows that k=3 would be good.

With reference to the statistical analysis results, we can prepare the code chunk as shown below.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "average",
          k_row = 3)
```

### **3.4 Seriation**

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "OLO")
```

The default options is “OLO” (Optimal leaf ordering) which optimizes the above criterion (in O(n\^4)). Another option is “GW” (Gruvaeus and Wainer) which aims for the same goal but uses a potentially faster heuristic.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "GW")
```

The option “mean” gives the output we would get by default from heatmap functions in other packages such as gplots::heatmap.2.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "mean")
```

The option “none” gives us the dendrograms without any rotation that is based on the data matrix.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none")
```

### **3.5 Working with colour palettes**

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none",
          colors = Blues)
```

### **3.6 The finishing touch**

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          Colv=NA,
          seriate = "none",
          colors = Blues,
          k_row = 5,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="World Happiness Score and Variables by Country, 2018 \nDataTransformation using Normalise Method",
          xlab = "World Happiness Indicators",
          ylab = "World Countries"
          )
```

# **`Visual Multivariate Analysis with Parallel Coordinates Plot`**

## **1 Getting Started**

### **1.1 Installing and loading the packages**

```{r}
pacman::p_load(GGally, parallelPlot, tidyverse)
```

### **1.2 Data import**

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

## **2 Plotting Static Parallel Coordinates Plot**

### **2.1 Plotting a simple parallel coordinates**

Code chunk below shows a typical syntax used to plot a basic static parallel coordinates plot by using `ggparcoord()`.

```{r}
ggparcoord(data = wh, 
           columns = c(7:12))
```

### **2.2 Plotting a parallel coordinates with boxplot**

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Parallel Coordinates Plot of World Happines Variables")
```

### **2.3 Parallel coordinates with facet**

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region)
```

### **2.4 Rotating x-axis text label**

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region) + 
  theme(axis.text.x = element_text(angle = 30))
```

### **2.5 Adjusting the rotated x-axis text label**

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region) + 
  theme(axis.text.x = element_text(angle = 30, hjust=1))
```

## **3 Plotting Interactive Parallel Coordinates Plot: parallelPlot methods**

### **3.1 The basic plot**

The code chunk below plot an interactive parallel coordinates plot by using `parallelPlot()`.

```{r}
wh <- wh %>%
  select("Happiness score", c(7:12))
parallelPlot(wh,
             width = 320,
             height = 250)
```

### **3.2 Rotate axis label**

In the code chunk below, `rotateTitle` argument is used to avoid overlapping axis labels.

```{r}
parallelPlot(wh,
             rotateTitle = TRUE)
```

### **3.3 Changing the colour scheme**

We can change the default blue colour scheme by using `continousCS` argument as shown in the code chunl below.

```{r}
parallelPlot(wh,
             continuousCS = "YlOrRd",
             rotateTitle = TRUE)
```

### **3.4 Parallel coordinates plot with histogram**

In the code chunk below, `histoVisibility` argument is used to plot histogram along the axis of each variables.

```{r}
histoVisibility <- rep(TRUE, ncol(wh))
parallelPlot(wh,
             rotateTitle = TRUE,
             histoVisibility = histoVisibility)
```

# **`Treemap Visualisation with R`**

## **1 Getting Started**

### **1.1 Installing and loading the packages**

```{r}
pacman::p_load(treemap, treemapify, tidyverse) 
```

### **1.2 Data import**

```{r}
realis2018 <- read_csv("data/realis2018.csv")
```

### **1.3 Data preparation**

```{r}
realis2018_grouped <- group_by(realis2018, `Project Name`,
                               `Planning Region`, `Planning Area`, 
                               `Property Type`, `Type of Sale`)
realis2018_summarised <- summarise(realis2018_grouped, 
                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),
                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),
                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), 
                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))
```

### **1.4 Grouped summaries with the *pipe***

The code chunk below shows a more efficient way to tackle the same processes by using the *pipe*, %\>%:

```{r}
realis2018_summarised <- realis2018 %>% 
  group_by(`Project Name`,`Planning Region`, 
           `Planning Area`, `Property Type`, 
           `Type of Sale`) %>%
  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), 
            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),
            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),
            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))
```

## **2 Designing Treemap with treemap Package**

### **2.1 Designing a static treemap**

In this section, *treemap()* of **Treemap** package is used to plot a treemap showing the distribution of median unit prices and total unit sold of resale condominium by geographic hierarchy in 2017.

First, we will select records belongs to resale condominium property type from *realis2018_selected* data frame.

```{r}
realis2018_selected <- realis2018_summarised %>%
  filter(`Property Type` == "Condominium", `Type of Sale` == "Resale")
```

### **2.2 Using the basic arguments**

The code chunk below designed a treemap by using three core arguments of *treemap()*, namely: *index*, *vSize* and *vColor*.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **2.3 Working with *vColor* and *type* arguments**

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type = "value",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **2.4 The “value” type treemap**

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="value",
        palette="RdYlBu", 
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

Thing to learn from the code chunk above:

-   although the colour palette used is RdYlBu but there are no red rectangles in the treemap above. This is because all the median unit prices are positive.

-   The reason why we see only 5000 to 45000 in the legend is because the *range* argument is by default c(min(values, max(values)) with some pretty rounding.

### **2.5 The “manual” type treemap**

The value range is mapped linearly to the colour palette.

The code chunk below shows a manual type treemap.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="RdYlBu", 
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

Update plot:

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="Blues", 
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **2.6 Working with *algorithm* argument**

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="Blues", 
        algorithm = "squarified",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **2.7 Using *sortID***

When “pivotSize” algorithm is used, *sortID* argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="Blues", 
        algorithm = "pivotSize",
        sortID = "Median Transacted Price",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

## **3 Designing Treemap using treemapify Package**

### **3.1 Designing a basic treemap**

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`),
       layout = "scol",
       start = "bottomleft") + 
  geom_treemap() +
  scale_fill_gradient(low = "light blue", high = "blue")
```

### **3.2 Defining hierarchy**

Group by Planning Region

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`,
           subgroup = `Planning Region`),
       start = "topleft") + 
  geom_treemap()
```

Group by Planning Area

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`,
           subgroup = `Planning Region`,
           subgroup2 = `Planning Area`)) + 
  geom_treemap()
```

Adding boundary line

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`,
           subgroup = `Planning Region`,
           subgroup2 = `Planning Area`)) + 
  geom_treemap() +
  geom_treemap_subgroup2_border(colour = "gray40",
                                size = 2) +
  geom_treemap_subgroup_border(colour = "gray20")
```

## **4 Designing Interactive Treemap using d3treeR**

### **4.1 Installing *d3treeR* package**

```{r}
library(devtools)
install_github("timelyportfolio/d3treeR")
```

```{r}
library(d3treeR)
```

### **4.2 Designing An Interactive Treemap**

1.  *treemap()* is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object called ***tm***.

```{r}
tm <- treemap(realis2018_summarised,
        index=c("Planning Region", "Planning Area"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="value",
        title="Private Residential Property Sold, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

2.  Then *d3tree()* is used to build an interactive treemap.

    ```{r}
    d3tree(tm,rootname = "Singapore" )
    ```
